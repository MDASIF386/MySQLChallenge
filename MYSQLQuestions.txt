SQL Question DAY1Ô∏è‚É£:
------------------------------
PROBLEM STATEMENT
Employee_8 Table has four columns namely EmpID EmpName, Salary and DeptID
Write a SQL to find all Employee_8s who earn more than the average salary in their corresponding department.
------------------------------


-------------------------------------------------------------------------
Table and Insert SQL Script :
-------------------------------------------------------------------------
CREATE Table Employee_8
(
EmpID INT,
EmpName Varchar(30),
Salary Float,
DeptID INT
);

INSERT INTO Employee_8 VALUES(1001,'Mark',60000,2);
INSERT INTO Employee_8 VALUES(1002,'Antony',40000,2);
INSERT INTO Employee_8 VALUES(1003,'Andrew',15000,1);
INSERT INTO Employee_8 VALUES(1004,'Peter',35000,1);
INSERT INTO Employee_8 VALUES(1005,'John',55000,1);
INSERT INTO Employee_8 VALUES(1006,'Albert',25000,3);
INSERT INTO Employee_8 VALUES(1007,'Donald',35000,3);

------------------------------
input table
------------------------------
+-------+---------+--------+--------+
| EmpID | EmpName | Salary | DeptID |
+-------+---------+--------+--------+
| 1001 | Mark | 60000 | 2 |
| 1002 | Antony | 40000 | 2 |
| 1003 | Andrew | 15000 | 1 |
| 1004 | Peter | 35000 | 1 |
| 1005 | John | 55000 | 1 |
| 1006 | Albert | 25000 | 3 |
| 1007 | Donald | 35000 | 3 |
+-------+---------+--------+--------+

------------------------------
Expected OUTPUT
------------------------------
+---------+--------+--------+
| EmpName | DeptID | Salary |
+---------+--------+--------+
| Mark | 2 | 60000 |
| John | 1 | 55000 |
| Donald | 3 | 35000 |
+---------+--------+--------+

------------------------------
solution
------------------------------
------------------------------
Method 1
------------------------------
with cte as
(
select
avg(Salary) as AV,
DeptID
from
Employee_8
group by DeptID
)
select E.EmpName,
E.DeptID,
E.Salary
from
Employee_8 E
join
cte C on E.DeptID=C.DeptID
where E.Salary>AV;

------------------------------
Method 2:
------------------------------
Select EmpName, DeptID, Salary from (select EmpID, EmpName, DeptID, Salary, AVG(Salary) over (Partition By DeptID) avs from Employee_8 order by DeptID) where Salary>avs order by Salary desc;

------------------------------
End
------------------------------

Tool Used: MYSQL

#sql #database #dataanalyst #practices
#data #technology #learning #interview
#dataengineering #dataanalytics #scenario
#sqlqueries #learningeveryday #day1



SQL Question DAY2Ô∏è‚É£:
------------------------------
PROBLEM STATEMENT
Employee_8 Table has four columns namely EmpID EmpName, Salary and DeptID
Write a SQL to find all Employee_8s who earn maximum salary in their respective department.
------------------------------


-------------------------------------------------------------------------
Table and Insert SQL Script :
-------------------------------------------------------------------------
CREATE Table Employee_8
(
EmpID INT,
EmpName Varchar(30),
Salary Float,
DeptID INT
);

INSERT INTO Employee_8 VALUES(1001,'Mark',60000,2);
INSERT INTO Employee_8 VALUES(1002,'Antony',40000,2);
INSERT INTO Employee_8 VALUES(1003,'Andrew',15000,1);
INSERT INTO Employee_8 VALUES(1004,'Peter',35000,1);
INSERT INTO Employee_8 VALUES(1005,'John',55000,1);
INSERT INTO Employee_8 VALUES(1006,'Albert',25000,3);
INSERT INTO Employee_8 VALUES(1007,'Donald',35000,3);

------------------------------
input table
------------------------------
+-------+---------+--------+--------+
| EmpID | EmpName | Salary | DeptID |
+-------+---------+--------+--------+
| 1001 | Mark | 60000 | 2 |
| 1002 | Antony | 40000 | 2 |
| 1003 | Andrew | 15000 | 1 |
| 1004 | Peter | 35000 | 1 |
| 1005 | John | 55000 | 1 |
| 1006 | Albert | 25000 | 3 |
| 1007 | Donald | 35000 | 3 |
+-------+---------+--------+--------+

------------------------------
Expected OUTPUT
------------------------------
+---------+--------+--------+
| EmpName | DeptID | Salary |
+---------+--------+--------+
| Mark | 2 | 60000 |
| John | 1 | 55000 |
| Donald | 3 | 35000 |
+---------+--------+--------+

------------------------------
solution
------------------------------
------------------------------
Method 1
------------------------------
select EmpName, DeptID, Salary from
(select EmpID, EmpName, Salary, DeptID, row_number() over(Partition By DeptID order by salary desc) as rown
from Employee_8)where rown=1 order by salary desc;

------------------------------
Method 2:
------------------------------
SELECT EmpName, e.DeptID, Salary
FROM Employee_8 e
JOIN (
  SELECT DeptID, MAX(Salary) AS MaxSalary
  FROM Employee_8
  GROUP BY DeptID
) max_salaries
ON e.DeptID = max_salaries.DeptID AND e.Salary = max_salaries.MaxSalary;



SQL Question DAY 5Ô∏è‚É£  : 



PROBLEM STATEMENT:

Transatcion_Tbl_1 Table has four columns CustID, TranID, TranAmt, and TranDate. User has to display all these fields along with maximum TranAmt for each CustID and ratio of TranAmt and maximum TranAmt for each transaction.

 -----------------

Outcome:

 ------------------------------

 Create insert query 

 ------------------------------

CREATE TABLE sql_question.Transaction_Tbl_1 

(

 CustID int ,

 TranID int ,

 TranAmt float ,

 TranDate date 

) ;



INSERT into Transaction_Tbl_1 VALUES (1001, 20001, 10000, CAST('2020-04-25' AS Date));

INSERT into Transaction_Tbl_1 VALUES (1001, 20002, 15000, CAST('2020-04-25' AS Date));

INSERT into Transaction_Tbl_1 VALUES (1001, 20003, 80000, CAST('2020-04-25' AS Date));

INSERT into Transaction_Tbl_1 VALUES (1001, 20004, 20000, CAST('2020-04-25' AS Date));

INSERT into Transaction_Tbl_1 VALUES (1002, 30001, 7000, CAST('2020-04-25' AS Date));

INSERT into Transaction_Tbl_1 VALUES (1002, 30002, 15000, CAST('2020-04-25' AS Date));

INSERT into Transaction_Tbl_1 VALUES (1002, 30003, 22000, CAST('2020-04-25' AS Date));



+--------+--------+---------+------------+

| CustID | TranID | TranAmt | TranDate |

+--------+--------+---------+------------+

| 1001 | 20001 | 10000 | 2020-04-25 |

| 1001 | 20002 | 15000 | 2020-04-25 |

| 1001 | 20003 | 80000 | 2020-04-25 |

| 1001 | 20004 | 20000 | 2020-04-25 |

| 1002 | 30001 | 7000 | 2020-04-25 |

| 1002 | 30002 | 15000 | 2020-04-25 |

| 1002 | 30003 | 22000 | 2020-04-25 |

+--------+--------+---------+------------+

Expected output :

+--------+--------+---------+------------+-----------------+-------------------------+

| CustID | TranID | TranAmt | TranDate | maximum_TranAmt | TranAmt/maximum_TranAmt |

+--------+--------+---------+------------+-----------------+-------------------------+

| 1001 | 20001 | 10000 | 2020-04-25 | 80000 | 0.125 |

| 1001 | 20002 | 15000 | 2020-04-25 | 80000 | 0.1875 |

| 1001 | 20003 | 80000 | 2020-04-25 | 80000 | 1 |

| 1001 | 20004 | 20000 | 2020-04-25 | 80000 | 0.25 |

| 1002 | 30001 | 7000 | 2020-04-25 | 22000 | 0.3181818181818182 |

| 1002 | 30002 | 15000 | 2020-04-25 | 22000 | 0.6818181818181818 |

| 1002 | 30003 | 22000 | 2020-04-25 | 22000 | 1 |

+--------+--------+---------+------------+-----------------+-------------------------+



Solution:

SELECT 

  CustID, 

  TranID, 

  TranAmt, 

  TranDate, 

  maximum_TranAmt, 

  (TranAmt / maximum_TranAmt) AS TranAmt_Ratio

FROM 

  (SELECT 

    CustID, 

    TranID, 

    TranAmt, 

    TranDate, 

    MAX(TranAmt) OVER (PARTITION BY CustID ORDER BY CustID) AS maximum_TranAmt 

  FROM 

    Transaction_Tbl_1) AS temp
    

    #data

    SQL Question DAY 3Ô∏è‚É£ :
------------------------------
PROBLEM STATEMENT
Employee_8 Table has four columns namely EmpID EmpName, Salary and DeptID
Write a SQL to find all Employee_New who earn Second highest salary in their respective department.
------------------------------


-------------------------------------------------------------------------
Table and Insert SQL Script :
-------------------------------------------------------------------------
CREATE Table Employee_8
(
EmpID INT,
EmpName Varchar(30),
Salary Float,
DeptID INT
);

INSERT INTO Employee_New VALUES(1001,'Ronaldo',60000,2);
INSERT INTO Employee_New VALUES(1002,'Messi',40000,2);
INSERT INTO Employee_New VALUES(1003,'Vini',43000,2);
INSERT INTO Employee_New VALUES(1004,'Mbappe',15000,1);
INSERT INTO Employee_New VALUES(1005,'Giroud',35000,1);
INSERT INTO Employee_New VALUES(1006,'Rashford',45000,1);
INSERT INTO Employee_New VALUES(1007,'Sancho',25000,3);
INSERT INTO Employee_New VALUES(1008,'Ramos',75000,3);
INSERT INTO Employee_New VALUES(1009,'Gavi',95000,3);

------------------------------
Input table:
------------------------------
+-------+---------+--------+--------+
| EmpID | EmpName | Salary | DeptID |
+-------+---------+--------+--------+
| 1001 | Ronaldo | 60000 | 2 |
| 1002 | Messi | 40000 | 2 |
| 1003 | Vini | 43000 | 2 |
| 1004 | Mbappe | 15000 | 1 |
| 1005 | Giroud | 35000 | 1 |
| 1006 | Rashford | 45000 | 1 |
| 1007 | Sancho | 25000 | 3 |
| 1008 | Ramos | 75000 | 3 |
| 1009 | Gavi | 95000 | 3 |
+-------+---------+--------+--------+

------------------------------
Expected OUTPUT
------------------------------
+---------+--------+--------+
| EmpName | DeptID | Salary |
+---------+--------+--------+
| Giroud| 1 | 35000 |
| Vini | 2 | 43000 |
| Ramos| 3 | 75000 |
+---------+--------+--------+

------------------------------
Solution
------------------------------
------------------------------
Method 1
------------------------------
Select EmpName, DeptID, Salary from 
(select EmpName,DeptID,Salary, row_number() over(Partition By DeptID order by Salary desc)rownum
from Employee_New)temp1 
where rownum=2;
------------------------------

End
------------------------------

Tool Used: MYSQL
#data

------------------------------

 SQL ‚û°Ô∏èDay 7Ô∏è‚É£ ‚û°Ô∏è :



 PROBLEM STATEMENT 

 Student Table has three columns Student_Name, Total_Marks and Year. 



Question :Write a SQL query to display Student_Name, 

 Total_Marks, Year, Prev_Yr_Marks for those whose Total_Marks are greater than or equal to the previous year. 

 ------------------------------

 

-------------------------------------------------------------------------

Table and Insert SQL Script :

-------------------------------------------------------------------------

CREATE TABLE Student_3(

Student_Name varchar(30),

Total_Marks int ,

Year int)



INSERT INTO Student_3 VALUES ('Rahul',90,2010);

INSERT INTO Student_3 VALUES('Sanjay',80,2010);

INSERT INTO Student_3 VALUES('Mohan',70,2010);

INSERT INTO Student_3 VALUES('Rahul',90,2011);

INSERT INTO Student_3 VALUES('Sanjay',85,2011);

INSERT INTO Student_3 VALUES('Mohan',65,2011);

INSERT INTO Student_3 VALUES('Rahul',80,2012);

INSERT INTO Student_3 VALUES('Sanjay',80,2012);

INSERT INTO Student_3 VALUES('Mohan',90,2012);



INPUT:

----------------+---------------+------

Student_Name|    Total_Marks |Year

----------------+---------------+------

Rahul	| 90  |	2010

Sanjay	| 80  |	2010

Mohan	| 70  |	2010

Rahul	| 90  |	2011

Sanjay	| 85  |	2011

Mohan	| 65  |	2011

Rahul	| 80  |	2012

Sanjay	| 80  |	2012

Mohan | 90  |	2012

------------------------------------------

Output:

----------------+------------+-------+------

Student_name	|total_marks	|year	pre

----------------+------------+-------+------

Mohan	            |90	            |2012	|65

Rahul	            |90	            |2011	|90

Sanjay	            |85	            |2011	|80

----------------+------------+-------+------



Solution:

+-----------+

Method 1:

+-----------+

with cte as(

select 

Student_name,

total_marks,

lag(total_marks) over(partition by Student_name) as pre,

year 

from Student_3 

order by student_name

)

select student_name,total_marks,year,pre

from cte

where total_marks>=pre



+-----------+

Method 2:

+-----------+

select a.student_name,a.total_marks,a.year,b.total_marks from Student_3 a join 

Student_3 b on 

a.student_name=b.student_name

where a.year=b.year+1 and a.total_marks>=b.total_marks;







---------------------------------------------------------------------







Do comment your solution and help with different approaches.

Note üìù : For solution check comment 







#sql #database #dataanalyst #practices

#data #technology #learning #interview

#dataengineering #dataanalytics #scenarioanalysis

#sqlqueries #learningeveryday #day7   #scenariosax

SQL ‚û°Ô∏èDay 7Ô∏è‚É£ ‚û°Ô∏è Question 1Ô∏è‚É£
                   PROBLEM STATEMENT 
Order_Tbl has four columns namely ORDER_DAY, ORDER_ID, PRODUCT_ID, QUANTITY and PRICE
(a) Write a SQL to get the highest sold Products (Quantity*Price) on both the days 
(b) Write a SQL to get all product's total sales on 1st May and 2nd May adjacent to each other
(c) Write a SQL to get all products day wise, that was ordered more than once
 ------------------------------
-------------------------------------------------------------------------
Table and Insert SQL Script :
-------------------------------------------------------------------------
CREATE TABLE Order_Tb_5(
 ORDER_DAY date,
 ORDER_ID varchar(10) ,
 PRODUCT_ID varchar(10) ,
 QUANTITY int ,
 PRICE int 
);

INSERT INTO Order_Tb_5 VALUES ('2015-05-01','ODR1', 'PROD1', 5, 5);
INSERT INTO Order_Tb_5 VALUES ('2015-05-01','ODR2', 'PROD2', 2, 10);
INSERT INTO Order_Tb_5 VALUES ('2015-05-01','ODR3', 'PROD3', 10, 25);
INSERT INTO Order_Tb_5 VALUES ('2015-05-01','ODR4', 'PROD1', 20, 5);
INSERT INTO Order_Tb_5 VALUES ('2015-05-02','ODR5', 'PROD3', 5, 25);
INSERT INTO Order_Tb_5 VALUES ('2015-05-02','ODR6', 'PROD4', 6, 20);
INSERT INTO Order_Tb_5 VALUES ('2015-05-02','ODR7', 'PROD1', 2, 5);
INSERT INTO Order_Tb_5 VALUES ('2015-05-02','ODR8', 'PROD5', 1, 50);
INSERT INTO Order_Tb_5 VALUES ('2015-05-02','ODR9', 'PROD6', 2, 50);
INSERT INTO Order_Tb_5 VALUES ('2015-05-02','ODR10','PROD2', 4, 10);
hjjv


 ------------------------------

 SQL ‚û°Ô∏èDay 9Ô∏è‚É£  ‚û°Ô∏è Question :

PROBLEM STATEMENT 

Order_Tbl has four columns namely ORDER_DAY, ORDER_ID, PRODUCT_ID, QUANTITY and PRICE

(a) Write a SQL to get all the products that got sold on both the days and the number of times the product is sold.

(b) Write a SQL to get products that was ordered on 02-May-2015 but not on 01-May-2015

 ------------------------------ 





-------------------------------------------------------------------------

Table and Insert SQL Script :

-------------------------------------------------------------------------

CREATE TABLE Order_Tb_5(

 ORDER_DAY date,

 ORDER_ID varchar(10) ,

 PRODUCT_ID varchar(10) ,

 QUANTITY int ,

 PRICE int 

);



INSERT INTO Order_Tb_5 VALUES ('2015-05-01','ODR1', 'PROD1', 5, 5);

INSERT INTO Order_Tb_5 VALUES ('2015-05-01','ODR2', 'PROD2', 2, 10);

INSERT INTO Order_Tb_5 VALUES ('2015-05-01','ODR3', 'PROD3', 10, 25);

INSERT INTO Order_Tb_5 VALUES ('2015-05-01','ODR4', 'PROD1', 20, 5);

INSERT INTO Order_Tb_5 VALUES ('2015-05-02','ODR5', 'PROD3', 5, 25);

INSERT INTO Order_Tb_5 VALUES ('2015-05-02','ODR6', 'PROD4', 6, 20);

INSERT INTO Order_Tb_5 VALUES ('2015-05-02','ODR7', 'PROD1', 2, 5);

INSERT INTO Order_Tb_5 VALUES ('2015-05-02','ODR8', 'PROD5', 1, 50);

INSERT INTO Order_Tb_5 VALUES ('2015-05-02','ODR9', 'PROD6', 2, 50);

INSERT INTO Order_Tb_5 VALUES ('2015-05-02','ODR10','PROD2', 4, 10);









OUTPUT:

------------------------------

Method 1: solution A

------------------------------

select product_id,

count(*) as cnt,

count(distinct order_day),

group_concat(QUANTITY)

from Order_Tb_5 

group by product_id

having cnt>=2;



------------------------------

Method 1: solution B

------------------------------



select 

product_id

from 

Order_Tb_5

where 

ORDER_DAY='2015-05-02'

and product_id not in (select product_id from Order_Tb_5 where ORDER_DAY='2015-05-01');

Do comment your solution and help with different approaches.

.



#sql #database #dataanalyst #practices

#data #technology #learning #interview

#dataengineering #dataanalytics #scenarioanalysis

#sqlqueriess

------------------------------

 SQL ‚û°Ô∏èDay 1Ô∏è‚É£ 0Ô∏è‚É£ ‚û°Ô∏è Question :

 PROBLEM STATEMENT :

 Write a query to find number who has done both inc & out and sum of duration of out is greater than sum of duration of inc

 ------------------------------

 

-------------------------------------------------------------------------

Table and Insert SQL Script :

-------------------------------------------------------------------------

create table call_det_10 (

call_type varchar(21),

call_num int,

dur int);



insert into call_det_10 values('OUT',98456,10);

insert into call_det_10 values('OUT',98456,12);

insert into call_det_10 values('OUT',98989,5);

insert into call_det_10 values('INC',12121,7);

insert into call_det_10 values('INC',98456,14);

insert into call_det_10 values('INC',98989,8);

insert into call_det_10 values('SMS',98456,10);

insert into call_det_10 values('OUT',98452,12);

insert into call_det_10 values('INC',98982,5);



Solution:

------------------------------------------------------------------------------

With cte as

(select *,sum(dur) over(partition by call_type order by call_type)rn from call_det_10 where call_type = 'out')

,cte1 as 

(select *,sum(dur) over(partition by call_type order by call_type)rn from call_det_10 where call_type = 'inc')



select distinct c2.call_num from cte1 c2

inner join cte c on c2.call_num = c.call_num and c.rn> c2.rn



---------------------------------------------------------------------------



Do comment your solution and help with different approaches.





#sql #database #dataanalyst #practices

#data #technology #learning #interview

#dataengineering #dataanalytics #scenarioanalysis
 #learningeveryday #day10  #scenariotesting #scenario

 ------------------------------
SQL ‚û°Ô∏èDay 1Ô∏è‚É£ 1Ô∏è‚É£‚û°Ô∏è Question 

 PROBLEM STATEMENT 
Write sql query to produce output as show below 
------------------------------
 
-------------------------------------------------------------------------
Table and Insert SQL Script :
-------------------------------------------------------------------------
create table testing_11 (device_id int,location varchar(21));

insert into testing_11 values(12,'bangalore');
insert into testing_11 values(12,'bangalore');
insert into testing_11 values(12,'bangalore');
insert into testing_11 values(12,'bangalore');
insert into testing_11 values(12,'hosur');
insert into testing_11 values(12,'hosur');
insert into testing_11 values(13,'hydrabad');
insert into testing_11 values(13,'hydrabad');
insert into testing_11 values(13,'secundrabad');
insert into testing_11 values(13,'secundrabad');
insert into testing_11 values(13,'secundrabad');

Solution:
------------------------------------
Method 1
------------------------------------
with CTE2 as 
(
with CTE as
(
select device_id,count(*) as total_signal,location
from testing_11
group by device_id,location
)
select device_id, 
total_signal,
location,
rank() over( partition by device_id order by total_signal desc) as rk,
sum(total_signal) over(partition by device_id) as tol
from CTE
)
select 
device_id,
tol as total_signal,
location
from CTE2
where 
rk=1;





Do comment your solution and help with different approaches.

hashtag#sql hashtag#database hashtag#dataanalyst hashtag#practices
hashtag#data hashtag#technology hashtag#learning hashtag#interview
hashtag#dataengineering hashtag#dataanalytics hashtag#scenarioanalysis
hashtag#sqlqueries hashtag#learningeveryday hashtag#day11 hashtag#scenario hashtag#mondaymotivation

SQL ‚û°Ô∏èDay 1Ô∏è‚É£ 2Ô∏è‚É£ ‚û°Ô∏è Question 
PROBLEM STATEMENT 
Write a SQL Query to get result as shown in output?
------------------------------
 
-------------------------------------------------------------------------
Table and Insert SQL Script :
-------------------------------------------------------------------------
create table Data_16( Name varchar(20));

insert into Data_16 value ('101');
insert into Data_16 value ('Akash');
insert into Data_16 value ('Mahindrakar');
insert into Data_16 value ('Mumbai');
insert into Data_16 value ('102');
insert into Data_16 value ('Akshay');
insert into Data_16 value ('Shirali');
insert into Data_16 value ('Pune');

Solution:
-----------
Method 1:
-------------
with tt as
(
select Name, CEIL(rownum/4) idd from data_16
)
select
max(case when mod(rownum, 4) = 1 then Name else Null end) id,
max(case when mod(rownum, 4) = 2 then Name else Null end) Fname,
max(case when mod(rownum, 4) = 3 then Name else Null end) Lname,
max(case when mod(rownum, 4) = 0 then Name else Null end) City
from tt
group by
idd
order by id;


-------------------------------------------------------------------------
Do comment your solution and help with different approaches.




hashtag#sql hashtag#database hashtag#dataanalyst hashtag#practices
hashtag#data hashtag#technology hashtag#learning hashtag#interview 
hashtag#dataengineering hashtag#dataanalytics hashtag#scenarioanalysis
hashtag#sqlqueries hashtag#learningeveryday hashtag#day12 hashtag#scenario #contentmarketing 

s