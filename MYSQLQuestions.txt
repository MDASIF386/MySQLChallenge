SQL Question DAY1Ô∏è‚É£:
------------------------------
PROBLEM STATEMENT
Employee_8 Table has four columns namely EmpID EmpName, Salary and DeptID
Write a SQL to find all Employee_8s who earn more than the average salary in their corresponding department.
------------------------------


-------------------------------------------------------------------------
Table and Insert SQL Script :
-------------------------------------------------------------------------
CREATE Table Employee_8
(
EmpID INT,
EmpName Varchar(30),
Salary Float,
DeptID INT
);

INSERT INTO Employee_8 VALUES(1001,'Mark',60000,2);
INSERT INTO Employee_8 VALUES(1002,'Antony',40000,2);
INSERT INTO Employee_8 VALUES(1003,'Andrew',15000,1);
INSERT INTO Employee_8 VALUES(1004,'Peter',35000,1);
INSERT INTO Employee_8 VALUES(1005,'John',55000,1);
INSERT INTO Employee_8 VALUES(1006,'Albert',25000,3);
INSERT INTO Employee_8 VALUES(1007,'Donald',35000,3);

------------------------------
input table
------------------------------
+-------+---------+--------+--------+
| EmpID | EmpName | Salary | DeptID |
+-------+---------+--------+--------+
| 1001 | Mark | 60000 | 2 |
| 1002 | Antony | 40000 | 2 |
| 1003 | Andrew | 15000 | 1 |
| 1004 | Peter | 35000 | 1 |
| 1005 | John | 55000 | 1 |
| 1006 | Albert | 25000 | 3 |
| 1007 | Donald | 35000 | 3 |
+-------+---------+--------+--------+

------------------------------
Expected OUTPUT
------------------------------
+---------+--------+--------+
| EmpName | DeptID | Salary |
+---------+--------+--------+
| Mark | 2 | 60000 |
| John | 1 | 55000 |
| Donald | 3 | 35000 |
+---------+--------+--------+

------------------------------
solution
------------------------------
------------------------------
Method 1
------------------------------
with cte as
(
select
avg(Salary) as AV,
DeptID
from
Employee_8
group by DeptID
)
select E.EmpName,
E.DeptID,
E.Salary
from
Employee_8 E
join
cte C on E.DeptID=C.DeptID
where E.Salary>AV;

------------------------------
Method 2:
------------------------------
Select EmpName, DeptID, Salary from (select EmpID, EmpName, DeptID, Salary, AVG(Salary) over (Partition By DeptID) avs from Employee_8 order by DeptID) where Salary>avs order by Salary desc;

------------------------------
End
------------------------------

Tool Used: MYSQL

#sql #database #dataanalyst #practices
#data #technology #learning #interview
#dataengineering #dataanalytics #scenario
#sqlqueries #learningeveryday #day1



SQL Question DAY2Ô∏è‚É£:
------------------------------
PROBLEM STATEMENT
Employee_8 Table has four columns namely EmpID EmpName, Salary and DeptID
Write a SQL to find all Employee_8s who earn maximum salary in their respective department.
------------------------------


-------------------------------------------------------------------------
Table and Insert SQL Script :
-------------------------------------------------------------------------
CREATE Table Employee_8
(
EmpID INT,
EmpName Varchar(30),
Salary Float,
DeptID INT
);

INSERT INTO Employee_8 VALUES(1001,'Mark',60000,2);
INSERT INTO Employee_8 VALUES(1002,'Antony',40000,2);
INSERT INTO Employee_8 VALUES(1003,'Andrew',15000,1);
INSERT INTO Employee_8 VALUES(1004,'Peter',35000,1);
INSERT INTO Employee_8 VALUES(1005,'John',55000,1);
INSERT INTO Employee_8 VALUES(1006,'Albert',25000,3);
INSERT INTO Employee_8 VALUES(1007,'Donald',35000,3);

------------------------------
input table
------------------------------
+-------+---------+--------+--------+
| EmpID | EmpName | Salary | DeptID |
+-------+---------+--------+--------+
| 1001 | Mark | 60000 | 2 |
| 1002 | Antony | 40000 | 2 |
| 1003 | Andrew | 15000 | 1 |
| 1004 | Peter | 35000 | 1 |
| 1005 | John | 55000 | 1 |
| 1006 | Albert | 25000 | 3 |
| 1007 | Donald | 35000 | 3 |
+-------+---------+--------+--------+

------------------------------
Expected OUTPUT
------------------------------
+---------+--------+--------+
| EmpName | DeptID | Salary |
+---------+--------+--------+
| Mark | 2 | 60000 |
| John | 1 | 55000 |
| Donald | 3 | 35000 |
+---------+--------+--------+

------------------------------
solution
------------------------------
------------------------------
Method 1
------------------------------
select EmpName, DeptID, Salary from
(select EmpID, EmpName, Salary, DeptID, row_number() over(Partition By DeptID order by salary desc) as rown
from Employee_8)where rown=1 order by salary desc;

------------------------------
Method 2:
------------------------------
SELECT EmpName, e.DeptID, Salary
FROM Employee_8 e
JOIN (
  SELECT DeptID, MAX(Salary) AS MaxSalary
  FROM Employee_8
  GROUP BY DeptID
) max_salaries
ON e.DeptID = max_salaries.DeptID AND e.Salary = max_salaries.MaxSalary;



SQL Question DAY 5Ô∏è‚É£  : 



PROBLEM STATEMENT:

Transatcion_Tbl_1 Table has four columns CustID, TranID, TranAmt, and TranDate. User has to display all these fields along with maximum TranAmt for each CustID and ratio of TranAmt and maximum TranAmt for each transaction.

 -----------------

Outcome:

 ------------------------------

 Create insert query 

 ------------------------------

CREATE TABLE sql_question.Transaction_Tbl_1 

(

 CustID int ,

 TranID int ,

 TranAmt float ,

 TranDate date 

) ;



INSERT into Transaction_Tbl_1 VALUES (1001, 20001, 10000, CAST('2020-04-25' AS Date));

INSERT into Transaction_Tbl_1 VALUES (1001, 20002, 15000, CAST('2020-04-25' AS Date));

INSERT into Transaction_Tbl_1 VALUES (1001, 20003, 80000, CAST('2020-04-25' AS Date));

INSERT into Transaction_Tbl_1 VALUES (1001, 20004, 20000, CAST('2020-04-25' AS Date));

INSERT into Transaction_Tbl_1 VALUES (1002, 30001, 7000, CAST('2020-04-25' AS Date));

INSERT into Transaction_Tbl_1 VALUES (1002, 30002, 15000, CAST('2020-04-25' AS Date));

INSERT into Transaction_Tbl_1 VALUES (1002, 30003, 22000, CAST('2020-04-25' AS Date));



+--------+--------+---------+------------+

| CustID | TranID | TranAmt | TranDate |

+--------+--------+---------+------------+

| 1001 | 20001 | 10000 | 2020-04-25 |

| 1001 | 20002 | 15000 | 2020-04-25 |

| 1001 | 20003 | 80000 | 2020-04-25 |

| 1001 | 20004 | 20000 | 2020-04-25 |

| 1002 | 30001 | 7000 | 2020-04-25 |

| 1002 | 30002 | 15000 | 2020-04-25 |

| 1002 | 30003 | 22000 | 2020-04-25 |

+--------+--------+---------+------------+

Expected output :

+--------+--------+---------+------------+-----------------+-------------------------+

| CustID | TranID | TranAmt | TranDate | maximum_TranAmt | TranAmt/maximum_TranAmt |

+--------+--------+---------+------------+-----------------+-------------------------+

| 1001 | 20001 | 10000 | 2020-04-25 | 80000 | 0.125 |

| 1001 | 20002 | 15000 | 2020-04-25 | 80000 | 0.1875 |

| 1001 | 20003 | 80000 | 2020-04-25 | 80000 | 1 |

| 1001 | 20004 | 20000 | 2020-04-25 | 80000 | 0.25 |

| 1002 | 30001 | 7000 | 2020-04-25 | 22000 | 0.3181818181818182 |

| 1002 | 30002 | 15000 | 2020-04-25 | 22000 | 0.6818181818181818 |

| 1002 | 30003 | 22000 | 2020-04-25 | 22000 | 1 |

+--------+--------+---------+------------+-----------------+-------------------------+



Solution:

SELECT 

  CustID, 

  TranID, 

  TranAmt, 

  TranDate, 

  maximum_TranAmt, 

  (TranAmt / maximum_TranAmt) AS TranAmt_Ratio

FROM 

  (SELECT 

    CustID, 

    TranID, 

    TranAmt, 

    TranDate, 

    MAX(TranAmt) OVER (PARTITION BY CustID ORDER BY CustID) AS maximum_TranAmt 

  FROM 

    Transaction_Tbl_1) AS temp
    

    #data

    SQL Question DAY 3Ô∏è‚É£ :
------------------------------
PROBLEM STATEMENT
Employee_8 Table has four columns namely EmpID EmpName, Salary and DeptID
Write a SQL to find all Employee_New who earn Second highest salary in their respective department.
------------------------------


-------------------------------------------------------------------------
Table and Insert SQL Script :
-------------------------------------------------------------------------
CREATE Table Employee_8
(
EmpID INT,
EmpName Varchar(30),
Salary Float,
DeptID INT
);

INSERT INTO Employee_New VALUES(1001,'Ronaldo',60000,2);
INSERT INTO Employee_New VALUES(1002,'Messi',40000,2);
INSERT INTO Employee_New VALUES(1003,'Vini',43000,2);
INSERT INTO Employee_New VALUES(1004,'Mbappe',15000,1);
INSERT INTO Employee_New VALUES(1005,'Giroud',35000,1);
INSERT INTO Employee_New VALUES(1006,'Rashford',45000,1);
INSERT INTO Employee_New VALUES(1007,'Sancho',25000,3);
INSERT INTO Employee_New VALUES(1008,'Ramos',75000,3);
INSERT INTO Employee_New VALUES(1009,'Gavi',95000,3);

------------------------------
Input table:
------------------------------
+-------+---------+--------+--------+
| EmpID | EmpName | Salary | DeptID |
+-------+---------+--------+--------+
| 1001 | Ronaldo | 60000 | 2 |
| 1002 | Messi | 40000 | 2 |
| 1003 | Vini | 43000 | 2 |
| 1004 | Mbappe | 15000 | 1 |
| 1005 | Giroud | 35000 | 1 |
| 1006 | Rashford | 45000 | 1 |
| 1007 | Sancho | 25000 | 3 |
| 1008 | Ramos | 75000 | 3 |
| 1009 | Gavi | 95000 | 3 |
+-------+---------+--------+--------+

------------------------------
Expected OUTPUT
------------------------------
+---------+--------+--------+
| EmpName | DeptID | Salary |
+---------+--------+--------+
| Giroud| 1 | 35000 |
| Vini | 2 | 43000 |
| Ramos| 3 | 75000 |
+---------+--------+--------+

------------------------------
Solution
------------------------------
------------------------------
Method 1
------------------------------
Select EmpName, DeptID, Salary from 
(select EmpName,DeptID,Salary, row_number() over(Partition By DeptID order by Salary desc)rownum
from Employee_New)temp1 
where rownum=2;
------------------------------

End
------------------------------

Tool Used: MYSQL
#data

------------------------------

 SQL ‚û°Ô∏èDay 7Ô∏è‚É£ ‚û°Ô∏è :



 PROBLEM STATEMENT 

 Student Table has three columns Student_Name, Total_Marks and Year. 



Question :Write a SQL query to display Student_Name, 

 Total_Marks, Year, Prev_Yr_Marks for those whose Total_Marks are greater than or equal to the previous year. 

 ------------------------------

 

-------------------------------------------------------------------------

Table and Insert SQL Script :

-------------------------------------------------------------------------

CREATE TABLE Student_3(

Student_Name varchar(30),

Total_Marks int ,

Year int)



INSERT INTO Student_3 VALUES ('Rahul',90,2010);

INSERT INTO Student_3 VALUES('Sanjay',80,2010);

INSERT INTO Student_3 VALUES('Mohan',70,2010);

INSERT INTO Student_3 VALUES('Rahul',90,2011);

INSERT INTO Student_3 VALUES('Sanjay',85,2011);

INSERT INTO Student_3 VALUES('Mohan',65,2011);

INSERT INTO Student_3 VALUES('Rahul',80,2012);

INSERT INTO Student_3 VALUES('Sanjay',80,2012);

INSERT INTO Student_3 VALUES('Mohan',90,2012);



INPUT:

----------------+---------------+------

Student_Name|    Total_Marks |Year

----------------+---------------+------

Rahul	| 90  |	2010

Sanjay	| 80  |	2010

Mohan	| 70  |	2010

Rahul	| 90  |	2011

Sanjay	| 85  |	2011

Mohan	| 65  |	2011

Rahul	| 80  |	2012

Sanjay	| 80  |	2012

Mohan | 90  |	2012

------------------------------------------

Output:

----------------+------------+-------+------

Student_name	|total_marks	|year	pre

----------------+------------+-------+------

Mohan	            |90	            |2012	|65

Rahul	            |90	            |2011	|90

Sanjay	            |85	            |2011	|80

----------------+------------+-------+------



Solution:

+-----------+

Method 1:

+-----------+

with cte as(

select 

Student_name,

total_marks,

lag(total_marks) over(partition by Student_name) as pre,

year 

from Student_3 

order by student_name

)

select student_name,total_marks,year,pre

from cte

where total_marks>=pre



+-----------+

Method 2:

+-----------+

select a.student_name,a.total_marks,a.year,b.total_marks from Student_3 a join 

Student_3 b on 

a.student_name=b.student_name

where a.year=b.year+1 and a.total_marks>=b.total_marks;







---------------------------------------------------------------------







Do comment your solution and help with different approaches.

Note üìù : For solution check comment 







#sql #database #dataanalyst #practices

#data #technology #learning #interview

#dataengineering #dataanalytics #scenarioanalysis

#sqlqueries #learningeveryday #day7   #scenariosax

SQL ‚û°Ô∏èDay 7Ô∏è‚É£ ‚û°Ô∏è Question 1Ô∏è‚É£
                   PROBLEM STATEMENT 
Order_Tbl has four columns namely ORDER_DAY, ORDER_ID, PRODUCT_ID, QUANTITY and PRICE
(a) Write a SQL to get the highest sold Products (Quantity*Price) on both the days 
(b) Write a SQL to get all product's total sales on 1st May and 2nd May adjacent to each other
(c) Write a SQL to get all products day wise, that was ordered more than once
 ------------------------------
-------------------------------------------------------------------------
Table and Insert SQL Script :
-------------------------------------------------------------------------
CREATE TABLE Order_Tb_5(
 ORDER_DAY date,
 ORDER_ID varchar(10) ,
 PRODUCT_ID varchar(10) ,
 QUANTITY int ,
 PRICE int 
);

INSERT INTO Order_Tb_5 VALUES ('2015-05-01','ODR1', 'PROD1', 5, 5);
INSERT INTO Order_Tb_5 VALUES ('2015-05-01','ODR2', 'PROD2', 2, 10);
INSERT INTO Order_Tb_5 VALUES ('2015-05-01','ODR3', 'PROD3', 10, 25);
INSERT INTO Order_Tb_5 VALUES ('2015-05-01','ODR4', 'PROD1', 20, 5);
INSERT INTO Order_Tb_5 VALUES ('2015-05-02','ODR5', 'PROD3', 5, 25);
INSERT INTO Order_Tb_5 VALUES ('2015-05-02','ODR6', 'PROD4', 6, 20);
INSERT INTO Order_Tb_5 VALUES ('2015-05-02','ODR7', 'PROD1', 2, 5);
INSERT INTO Order_Tb_5 VALUES ('2015-05-02','ODR8', 'PROD5', 1, 50);
INSERT INTO Order_Tb_5 VALUES ('2015-05-02','ODR9', 'PROD6', 2, 50);
INSERT INTO Order_Tb_5 VALUES ('2015-05-02','ODR10','PROD2', 4, 10);
hjjv


 ------------------------------

 SQL ‚û°Ô∏èDay 9Ô∏è‚É£  ‚û°Ô∏è Question :

PROBLEM STATEMENT 

Order_Tbl has four columns namely ORDER_DAY, ORDER_ID, PRODUCT_ID, QUANTITY and PRICE

(a) Write a SQL to get all the products that got sold on both the days and the number of times the product is sold.

(b) Write a SQL to get products that was ordered on 02-May-2015 but not on 01-May-2015

 ------------------------------ 





-------------------------------------------------------------------------

Table and Insert SQL Script :

-------------------------------------------------------------------------

CREATE TABLE Order_Tb_5(

 ORDER_DAY date,

 ORDER_ID varchar(10) ,

 PRODUCT_ID varchar(10) ,

 QUANTITY int ,

 PRICE int 

);



INSERT INTO Order_Tb_5 VALUES ('2015-05-01','ODR1', 'PROD1', 5, 5);

INSERT INTO Order_Tb_5 VALUES ('2015-05-01','ODR2', 'PROD2', 2, 10);

INSERT INTO Order_Tb_5 VALUES ('2015-05-01','ODR3', 'PROD3', 10, 25);

INSERT INTO Order_Tb_5 VALUES ('2015-05-01','ODR4', 'PROD1', 20, 5);

INSERT INTO Order_Tb_5 VALUES ('2015-05-02','ODR5', 'PROD3', 5, 25);

INSERT INTO Order_Tb_5 VALUES ('2015-05-02','ODR6', 'PROD4', 6, 20);

INSERT INTO Order_Tb_5 VALUES ('2015-05-02','ODR7', 'PROD1', 2, 5);

INSERT INTO Order_Tb_5 VALUES ('2015-05-02','ODR8', 'PROD5', 1, 50);

INSERT INTO Order_Tb_5 VALUES ('2015-05-02','ODR9', 'PROD6', 2, 50);

INSERT INTO Order_Tb_5 VALUES ('2015-05-02','ODR10','PROD2', 4, 10);









OUTPUT:

------------------------------

Method 1: solution A

------------------------------

select product_id,

count(*) as cnt,

count(distinct order_day),

group_concat(QUANTITY)

from Order_Tb_5 

group by product_id

having cnt>=2;



------------------------------

Method 1: solution B

------------------------------



select 

product_id

from 

Order_Tb_5

where 

ORDER_DAY='2015-05-02'

and product_id not in (select product_id from Order_Tb_5 where ORDER_DAY='2015-05-01');

Do comment your solution and help with different approaches.

.



#sql #database #dataanalyst #practices

#data #technology #learning #interview

#dataengineering #dataanalytics #scenarioanalysis

#sqlqueriess

------------------------------

 SQL ‚û°Ô∏èDay 1Ô∏è‚É£ 0Ô∏è‚É£ ‚û°Ô∏è Question :

 PROBLEM STATEMENT :

 Write a query to find number who has done both inc & out and sum of duration of out is greater than sum of duration of inc

 ------------------------------

 

-------------------------------------------------------------------------

Table and Insert SQL Script :

-------------------------------------------------------------------------

create table call_det_10 (

call_type varchar(21),

call_num int,

dur int);



insert into call_det_10 values('OUT',98456,10);

insert into call_det_10 values('OUT',98456,12);

insert into call_det_10 values('OUT',98989,5);

insert into call_det_10 values('INC',12121,7);

insert into call_det_10 values('INC',98456,14);

insert into call_det_10 values('INC',98989,8);

insert into call_det_10 values('SMS',98456,10);

insert into call_det_10 values('OUT',98452,12);

insert into call_det_10 values('INC',98982,5);



Solution:

------------------------------------------------------------------------------

With cte as

(select *,sum(dur) over(partition by call_type order by call_type)rn from call_det_10 where call_type = 'out')

,cte1 as 

(select *,sum(dur) over(partition by call_type order by call_type)rn from call_det_10 where call_type = 'inc')



select distinct c2.call_num from cte1 c2

inner join cte c on c2.call_num = c.call_num and c.rn> c2.rn



---------------------------------------------------------------------------



Do comment your solution and help with different approaches.





#sql #database #dataanalyst #practices

#data #technology #learning #interview

#dataengineering #dataanalytics #scenarioanalysis
 #learningeveryday #day10  #scenariotesting #scenario

 ------------------------------
SQL ‚û°Ô∏èDay 1Ô∏è‚É£ 1Ô∏è‚É£‚û°Ô∏è Question 

 PROBLEM STATEMENT 
Write sql query to produce output as show below 
------------------------------
 
-------------------------------------------------------------------------
Table and Insert SQL Script :
-------------------------------------------------------------------------
create table testing_11 (device_id int,location varchar(21));

insert into testing_11 values(12,'bangalore');
insert into testing_11 values(12,'bangalore');
insert into testing_11 values(12,'bangalore');
insert into testing_11 values(12,'bangalore');
insert into testing_11 values(12,'hosur');
insert into testing_11 values(12,'hosur');
insert into testing_11 values(13,'hydrabad');
insert into testing_11 values(13,'hydrabad');
insert into testing_11 values(13,'secundrabad');
insert into testing_11 values(13,'secundrabad');
insert into testing_11 values(13,'secundrabad');

Solution:
------------------------------------
Method 1
------------------------------------
with CTE2 as 
(
with CTE as
(
select device_id,count(*) as total_signal,location
from testing_11
group by device_id,location
)
select device_id, 
total_signal,
location,
rank() over( partition by device_id order by total_signal desc) as rk,
sum(total_signal) over(partition by device_id) as tol
from CTE
)
select 
device_id,
tol as total_signal,
location
from CTE2
where 
rk=1;





Do comment your solution and help with different approaches.

hashtag#sql hashtag#database hashtag#dataanalyst hashtag#practices
hashtag#data hashtag#technology hashtag#learning hashtag#interview
hashtag#dataengineering hashtag#dataanalytics hashtag#scenarioanalysis
hashtag#sqlqueries hashtag#learningeveryday hashtag#day11 hashtag#scenario hashtag#mondaymotivation

SQL ‚û°Ô∏èDay 1Ô∏è‚É£ 2Ô∏è‚É£ ‚û°Ô∏è Question 
PROBLEM STATEMENT 
Write a SQL Query to get result as shown in output?
------------------------------
 
-------------------------------------------------------------------------
Table and Insert SQL Script :
-------------------------------------------------------------------------
create table Data_16( Name varchar(20));

insert into Data_16 value ('101');
insert into Data_16 value ('Akash');
insert into Data_16 value ('Mahindrakar');
insert into Data_16 value ('Mumbai');
insert into Data_16 value ('102');
insert into Data_16 value ('Akshay');
insert into Data_16 value ('Shirali');
insert into Data_16 value ('Pune');

Solution:
-----------
Method 1:
-------------
with tt as
(
select Name, CEIL(rownum/4) idd from data_16
)
select
max(case when mod(rownum, 4) = 1 then Name else Null end) id,
max(case when mod(rownum, 4) = 2 then Name else Null end) Fname,
max(case when mod(rownum, 4) = 3 then Name else Null end) Lname,
max(case when mod(rownum, 4) = 0 then Name else Null end) City
from tt
group by
idd
order by id;


-------------------------------------------------------------------------
Do comment your solution and help with different approaches.




hashtag#sql hashtag#database hashtag#dataanalyst hashtag#practices
hashtag#data hashtag#technology hashtag#learning hashtag#interview 
hashtag#dataengineering hashtag#dataanalytics hashtag#scenarioanalysis
hashtag#sqlqueries hashtag#learningeveryday hashtag#day12 hashtag#scenario #contentmarketing 

SQL ‚û°Ô∏èDay 1Ô∏è‚É£ 4Ô∏è‚É£ ‚û°Ô∏è Question:
 PROBLEM STATEMENT 
Write a query to find Average Time of Process per Machine
-------------------------------------------------------------------------
Table and Insert SQL Script :
-------------------------------------------------------------------------

Create table Activity (
machine_id int, 
process_id int, 
activity_type ENUM('start', 'end'), 
timestamp float);


insert into Activity (machine_id, process_id, activity_type, timestamp) values ('0', '0', 'start', '0.712');
insert into Activity (machine_id, process_id, activity_type, timestamp) values ('0', '0', 'end', '1.52');
insert into Activity (machine_id, process_id, activity_type, timestamp) values ('0', '1', 'start', '3.14');
insert into Activity (machine_id, process_id, activity_type, timestamp) values ('0', '1', 'end', '4.12');
insert into Activity (machine_id, process_id, activity_type, timestamp) values ('1', '0', 'start', '0.55');
insert into Activity (machine_id, process_id, activity_type, timestamp) values ('1', '0', 'end', '1.55');
insert into Activity (machine_id, process_id, activity_type, timestamp) values ('1', '1', 'start', '0.43');
insert into Activity (machine_id, process_id, activity_type, timestamp) values ('1', '1', 'end', '1.42');
insert into Activity (machine_id, process_id, activity_type, timestamp) values ('2', '0', 'start', '4.1');
insert into Activity (machine_id, process_id, activity_type, timestamp) values ('2', '0', 'end', '4.512');
insert into Activity (machine_id, process_id, activity_type, timestamp) values ('2', '1', 'start', '2.5');
insert into Activity (machine_id, process_id, activity_type, timestamp) values ('2', '1', 'end', '5.0');


Solution:
----------------
Method 1:
----------------
SELECT s.machine_id, s.process_id, e.timestamp, s.timestamp
FROM Activity_18 s
INNER JOIN Activity_18 e ON 
 (s.machine_id, s.process_id) = (e.machine_id, e.process_id)
 AND
 (s.activity_type='start')
 AND
 (e.activity_type='end');

----------------
Method 2:
----------------
select machine_id, process_id ,end_t as timestamp , timestamp from
(
select machine_id, process_id , lead(timestamp) over (partition by machine_id,process_id order by timestamp ) as end_t ,timestamp from Activity
)
where end_t is not null

Do comment your solution and help with different approach...

SQL ‚û°Ô∏èDay 1Ô∏è‚É£ 6Ô∏è‚É£ ‚û°Ô∏è Question 

  PROBLEM STATEMENT 

Write SQL to get the total Sales in year 1998,1999 and 2000 for all the products as shown below.

-----------------------------

-------------------------------------------------------------------------

Table and Insert SQL Script :

-------------------------------------------------------------------------



create table salestbl_20 (

id int identity (1,1), 

product varchar(20), 

salesyear int, 

QuantitySold int)



insert into salestbl_20 (product, salesyear, QuantitySold)

values ('Laptop', 1998, 2500), 

('Laptop', 1999, 3600),

('Laptop', 2000, 4200),

('Keyboard', 1998, 2300), 

('Keyboard',1999, 3600), 

('Keyboard', 2000, 5000),

('Mouse', 1998, 6000),

('Mouse', 1999, 3400), 

('Mouse', 2000, 4600) 



Solution:

-----------------------

Method 1:

-----------------------

with cte as(

select salesyear, sum(quantitysold) as ts from salestbl_20 

group by 1)

select TotalSales, max(year_1998) as year_1998, max(year_1999) as year_1999, max(year_2000) as year_2000

from (

select 'TotalSales' as TotalSales,

case 

when salesyear = 1998 then ts else NULL end as year_1998,

case

when salesyear = 1999 then ts else NULL end as year_1999,

case

when salesyear = 2000 then ts else NULL end as year_2000

from cte) a

group by TotalSales;



------------------------------------------------------------------

Method 2:

------------------------------------------------------------------

select 'Totalsales' as Totalsales,

SUM(CASE WHEN salesyear = '1998' THEN QuantitySold ELSE 0 END) as '1998',

SUM(CASE WHEN salesyear = '1999' THEN QuantitySold ELSE 0 END) as '1999',

SUM(CASE WHEN salesyear = '2000' THEN QuantitySold ELSE 0 END) as '2000' from salestbl_20;

--------------------------------------------------------------------

Do comment your solution and help with different approachesSQL ‚û°Ô∏èDay 1Ô∏è‚É£ 7Ô∏è‚É£ ‚û°Ô∏è Question 
------------------------------
 PROBLEM STATEMENT 
Write a sql query to calculate running total of Quantity of each product as show in output below.
------------------------------
----------------------------------------
Table and Insert SQL Script :
----------------------------------------

Create Table Inventory_21(
ProdName Varchar(20),
ProductCode Varchar(15),
Quantity int,
InventoryDate Date)

Insert Into Inventory_21 values('Keyboard','K1001',20,'2020-03-01');
Insert Into Inventory_21 values('Keyboard','K1001',30,'2020-03-02');
Insert Into Inventory_21 values('Keyboard','K1001',10,'2020-03-03');
Insert Into Inventory_21 values('Keyboard','K1001',40,'2020-03-04');
Insert Into Inventory_21 values('Laptop','L1002',100,'2020-03-01');
Insert Into Inventory_21 values('Laptop','L1002',60,'2020-03-02');
Insert Into Inventory_21 values('Laptop','L1002',40,'2020-03-03');
Insert Into Inventory_21 values('Monitor','M5005',30,'2020-03-01');
Insert Into Inventory_21 values('Monitor','M5005',20,'2020-03-02');


Solution:
----------
select 
*,
sum(Quantity) over( partition by ProductCode order by InventoryDate) as running_total 
from 
Inventory_21;

SQL ‚û°Ô∏èDay 1Ô∏è‚É£ 8Ô∏è‚É£ ‚û°Ô∏è Question 

   PROBLEM STATEMENT 

 

Write a sql query to Print Alphabets A to Z in SQL



----------------------

Expected output :

----------------------

A

B

C

D

.

.

Z



Solution:

-----------------------------------------------------------------------------------

Method 1:

============

SELECT Char(number+65) Letter

 FROM master.dbo.spt_values

 WHERE name IS NULL AND 

 number < 26

--------------------------------------------------------------------------------------

Method2:

==========

DECLARE @Start int 

set @Start=65 

while(@Start<=90) 

begin 

print char(@Start) 

set @Start=@Start+1 

end

-----------------------------------------------------------------------------------


SQL ‚û°Ô∏èDay 1Ô∏è‚É£ 9Ô∏è‚É£  ‚û°Ô∏è Question
PROBLEM STATEMENT ->

Let's try some basic theory questions today:
 
 What is SQL?
-> It stands for Structured Query Language. A programming language used for interaction with relational database management systems (RDBMS). This includes fetching, updating, inserting, and removing data from tables.

2) What are the types of SQL Commands?
-> a. Data Definition Language(DDL): to define and modify the structure of a database.
b. Data Manipulation Language(DML): to access, manipulate, and modify data in a database.
c. Data Query Language (DQL) ‚Äì to perform queries on the data in a database to retrieve the necessary information from it. 
d. Data Control Language (DCL) ‚Äì to control user access to the data in the database and give or revoke privileges to a specific user or a group of users.
e. Transaction Control Language (TCL) ‚Äì to control transactions in a database.

3) Give some examples of common SQL commands of each type?
-> a. DDL: Create, Alter Table, Drop and Truncate 
b. DML: Update, Delete and Insert
c. DQL: Select
d. DCL: Grant and Revoke
e. TCL: Commit, Roll back, Save Point, Set Transaction




SQL ‚û°Ô∏èDay 2Ô∏è‚É£ 0Ô∏è‚É£ ‚û°Ô∏è Question



PROBLEM STATEMENT 

The confirmation rate of a user is the number of 'confirmed' messages divided by the total number of requested confirmation messages. The confirmation rate of a user that did not request any confirmation messages is 0. Round the confirmation rate to two decimal places.

Write a solution to find the confirmation rate of each user.



INPUT:

Signups table:

+---------+---------------------+

| user_id | time_stamp |

+---------+---------------------+

| 3 | 2020-03-21 10:16:13 |

| 7 | 2020-01-04 13:57:59 |

| 2 | 2020-07-29 23:09:44 |

| 6 | 2020-12-09 10:39:37 |

+---------+---------------------+



Confirmations table:

+---------+---------------------+-----------+

| user_id | time_stamp | action |

+---------+---------------------+-----------+

| 3 | 2021-01-06 03:30:46 | timeout |

| 3 | 2021-07-14 14:00:00 | timeout |

| 7 | 2021-06-12 11:57:29 | confirmed |

| 7 | 2021-06-13 12:58:28 | confirmed |

| 7 | 2021-06-14 13:59:27 | confirmed |

| 2 | 2021-01-22 00:00:00 | confirmed |

| 2 | 2021-02-28 23:59:59 | timeout |

+---------+---------------------+-----------+



SOLUTION:

--------------------------------------------------------------------------------------+

WITH temp AS(

SELECT s.user_id,count(1)CN,

SUM(CASE WHEN action ="confirmed" THEN 1 ELSE 0 END ) AS CNT

FROM signups s

LEFT JOIN confirmations c

ON S.user_id=c.user_id

GROUP BY s.user_id)

SELECT user_id,round(cnt/cn,2) as confirmation_rate

FROM temp

---------------------------------------------------------------------------------------

OUTPUT:

+---------+-------------------+

| user_id | confirmation_rate |

+---------+-------------------+

| 6 | 0.00 |

| 3 | 0.00 |

| 7 | 1.00 |

| 2 | 0.50 |

+---------+-----------------

SQL ‚û°Ô∏èDay 2Ô∏è‚É£ 1Ô∏è‚É£‚û°Ô∏è Question->

PROBLEM STATEMENT 



Write SQL to turn the columns English, Maths and Science into rows. It should display Marks for each student for each subjects as shown below

------------------------------



-------------------------------------------------------------------------

Table and Insert SQL Script :

-------------------------------------------------------------------------



Create Table studentinfo_23(

studentname Varchar(20),

english int,

maths int,

science int);



insert into studentinfo_23 values ('David',85,90,88);

insert into studentinfo_23 values ('John',75,85,80);

insert into studentinfo_23 values ('Tom',83,80,92);

-----------------------------------------------------------------------------------

Solution

-----------------------------------------------------------------------------------

select StudentName, 'English' As Subject ,English as Marks from studentinfo_23

union all 

select StudentName, 'Maths' As Subject ,Maths as Marks from studentinfo_23

union all 

select StudentName, 'Science' As Subject ,Science as Marks from studentinfo_23

order by StudentName;

---------------------------------------------------------------------------------------



SQL ‚û°Ô∏èDay 2Ô∏è‚É£2Ô∏è‚É£  ‚û°Ô∏è Question 

   PROBLEM STATEMENT 

Write SQL to derive Start_Date and End_Date column when there is continuous amount in Balance column as shown below.

------------------------------



-------------------------------------------------------------------------

Table and Insert SQL Script :

-------------------------------------------------------------------------



Create Table BalanceTbl_25(

Balance int,

Dates Date

)



Insert into BalanceTbl_25 Values(26000,'2020-01-01')

Insert into BalanceTbl_25 Values(26000,'2020-01-02')

Insert into BalanceTbl_25 Values(26000,'2020-01-03')

Insert into BalanceTbl_25 Values(30000,'2020-01-04')

Insert into BalanceTbl_25 Values(30000,'2020-01-05')

Insert into BalanceTbl_25 Values(26000,'2020-01-06')

Insert into BalanceTbl_25 Values(26000,'2020-01-07')

Insert into BalanceTbl_25 Values(32000,'2020-01-08')

Insert into BalanceTbl_25 Values(31000,'2020-01-09')



---------------------------------------------------------------------------------------

Solution:

---------------------------------------------------------------------------------------

with cte as

(

select *, (rownum2 - rownum1) as Diff from

(

select *, ROW_NUMBER() over (partition by balance order by dates) as rownum1 ,

ROW_NUMBER() over (order by dates) as rownum2

from BalanceTbl_25



)res

)

select balance, min(dates) as StartDate, max(dates) as EndDate

from cte

group by balance,diff

order by StartDate;

--------------------------------------------------------------------------------------

Do comment your solution and help with different approaches.




SQL ‚û°Ô∏èDay 2Ô∏è‚É£ 2Ô∏è‚É£ ‚û°Ô∏è Question

------------------------------

 PROBLEM STATEMENT 

Write a query to print number of total match , won match and lost match by each team in cricket tournament.



INPUT:

create table world_cup

(

Team_1 Varchar(20),

Team_2 Varchar(20),

Winner Varchar(20)

);

INSERT INTO world_cup values('India','SL','India');

INSERT INTO world_cup values('SL','Aus','Aus');

INSERT INTO world_cup values('SA','Eng','Eng');

INSERT INTO world_cup values('Eng','NZ','NZ');

INSERT INTO world_cup values('Aus','India','India');



select * from world_cup;





SOLUTION:

---------------------------------------------------------------------------------------

SELECT 

  team_name,

  COUNT(*) AS total_match,

  SUM(win_flag) AS won_match,

  COUNT(*) - SUM(win_flag) AS lost_match

FROM

  (SELECT 

    team_1 AS team_name,

    CASE 

      WHEN winner = 'team_1' THEN 1 

      ELSE 0 

    END AS win_flag

  FROM 

    world_cup

  UNION ALL

  SELECT 

    team_2 AS team_name,

    CASE 

      WHEN winner = 'team_2' THEN 1 

      ELSE 0 

    END AS win_flag

  FROM 

    world_cup) a

GROUP BY 

  team_name

ORDER BY 

  won_match DESC;


---
----------------------------------------------------------------------------------
SQL ‚û°Ô∏èDay 2Ô∏è‚É£ 5Ô∏è‚É£  ‚û°Ô∏è Question:

   PROBLEM STATEMENT 

Write SQL to get Total sales amount in USD for each sales date as shown below :-  

------------------------------



-------------------------------------------------------------------------

Table and Insert SQL Script :

-------------------------------------------------------------------------





Create Table Sales_Table_26(

Sales_Date Date,

Sales_Amount Bigint,

Currency Varchar(10)

)



INSERT INTO Sales_Table_26 Values ('2020-01-01',500,'INR');

INSERT INTO Sales_Table_26 Values ('2020-01-01',100,'GBP');

INSERT INTO Sales_Table_26 Values ('2020-01-02',1000,'INR');

INSERT INTO Sales_Table_26 Values ('2020-01-02',500,'GBP');

INSERT INTO Sales_Table_26 Values ('2020-01-03',500,'INR');

INSERT INTO Sales_Table_26 Values ('2020-01-17',200,'GBP');



CREATE TABLE ExchangeRate_Table_26

(

 Source_Currency varchar(10) ,

 Target_Currency varchar(10),

 Exchange_Rate float,

 Effective_Start_Date date

)



INSERT INTO ExchangeRate_Table_26 VALUES ('INR','USD', 0.014,'2019-12-31');

INSERT INTO ExchangeRate_Table_26 VALUES ('INR','USD', 0.015,'2020-01-02');

INSERT INTO ExchangeRate_Table_26 VALUES ('GBP','USD', 1.32, '2019-12-20');

INSERT INTO ExchangeRate_Table_26 VALUES ('GBP','USD', 1.3, '2020-01-01' );

INSERT INTO ExchangeRate_Table_26 VALUES ('GBP','USD', 1.35, '2020-01-16');



OUTPUT->

---------------------------------------------------------------------------------------

SELECT Sales_Date, SUM(Sales_Amount * Exchange_Rate) FROM Sales_Table_26 s

LEFT JOIN ExchangeRate_Table_26 e1 

ON s.Currency = e1.Source_Currency 

AND e1.Effective_Start_Date = 

 (select MAX(e2.Effective_Start_Date) FROM ExchangeRate_Table_26 e2 WHERE s.Currency = e2.Source_Currency

 AND s.Sales_Date >= e2.Effective_Start_Date)

GROUP BY Sales_Date








SQL ‚û°Ô∏èDay 2Ô∏è‚É£ 7Ô∏è‚É£  ‚û°Ô∏è Question:

------------------------------------------------------------

üéØ  PROBLEM STATEMENT

 ----------------------------------------------

Write a SQL query for a report that provides the pairs (actor_id, director_id)

where the actor have cooperated with the director at least 3 times.

 üõçÔ∏èüí°

 

 

---------------------------------------------------------------------

üìù Table and Insert SQL Script :

-------------------------------------------------------------------------

create table ActorDirector

(

actor_id int,

director_id int,

timestamp int

)

 

insert into ActorDirector

values

(1,1,0),

(1,1,1),

(1,1,2),

(1,2,3),

(1,2,4),

(2,1,5),

(2,1,6)

 

------------------------------

Input table

------------------------------

+-------------+-------------+-------------+

| actor_id   | director_id | timestamp  |

+-------------+-------------+-------------+

| 1          | 1          | 0          |

| 1          | 1          | 1          |

| 1          | 1          | 2          |

| 1          | 2          | 3          |

| 1          | 2          | 4          |

| 2          | 1          | 5          |

| 2          | 1          | 6          |

+-------------+-------------+-------------+

------------------------------

OUTPUT

------------------------------

+-------------+-------------+

| actor_id   | director_id |

+----------+-------------+

| 1             |     1          |

+---------+-------------+

------------------------------------------------------------------------------------

Solution->

-------------------------------------------------------------------------------------

SELECT actor_id

        ,director_id

FROM ActorDirector

GROUP BY actor_id

        ,director_id

HAVING count(*) >= 3

--------------------------------------------------------------------------------------

#sql #database #dataanalyst #practices

#data #technology #learning #interview

#dataengineering #dataanalytics #scenarioanalysis


#sqlqueries #learningeveryday #day27 #scenario

SQL ‚û°Ô∏èDay 2Ô∏è‚É£ 8Ô∏è‚É£  ‚û°Ô∏è Question:

------------------------------------------------------------

üéØ PROBLEM STATEMENT

 ----------------------------------------------

Write an SQL query to find all the authors that viewed at least one of their own articles, sorted in ascending order by their id.

 

---------------------------------------------------------------------

üìù Table and Insert SQL Script :

-------------------------------------------------------------------------

 

create table article_views

(

article_id int,

author_id int,

viewer_id int,

view_date date

);

 

insert into article_views

values

(1,3,5,'2019‚Äì08‚Äì01'),

(1,3,6,'2019‚Äì08‚Äì02'),

(2,7,7,'2019‚Äì08‚Äì01'),

(2,7,6,'2019‚Äì08‚Äì02'),

(4,7,1,'2019‚Äì07‚Äì22'),

(3,4,4,'2019‚Äì07‚Äì21'),

(3,4,4,'2019‚Äì07‚Äì21');

 

 

------------------------------

input table

------------------------------

 

+------------+-----------+-----------+------------+

| article_id | author_id | viewer_id | view_date |

+------------+-----------+-----------+------------+

| 1         | 3        | 5        | 2019-08-01 |

| 1         | 3        | 6        | 2019-08-02 |

| 2         | 7        | 7        | 2019-08-01 |

| 2         | 7        | 6        | 2019-08-02 |

| 4         | 7        | 1        | 2019-07-22 |

| 3         | 4        | 4        | 2019-07-21 |

| 3         | 4        | 4        | 2019-07-21 |

+------------+-----------+-----------+------------+

 

 

------------------------------

OUTPUT

------------------------------

+------+

| id  |

+------+

| 4   |

| 7   |

+------+

------------------------------------------------------------------------------------

Solution->

-------------------------------------------------------------------------------------

SELECT DISTINCT author_id

FROM article_views

WHERE author_id = viewer_id

ORDER BY author_id;

--------------------------------------------------------------------------------------

SQL ‚û°Ô∏èDay 2Ô∏è‚É£ 9Ô∏è‚É£ ‚û°Ô∏è Question:

------------------------------------------------------------

üéØ  PROBLEM STATEMENT

 ----------------------------------------------

write an SQL query to find the average selling price for each product.

average_price should be rounded to 2 decimal places.





---------------------------------------------------------------------

üìù Table and Insert SQL Script :

-------------------------------------------------------------------------

 

create table prices

(

product_id int,

start_date date,

end_date date,

price int

);

 

insert into prices

values

(1,‚Äô2019‚Äì02‚Äì17',‚Äô2019‚Äì02‚Äì28',5),

(1,‚Äô2019‚Äì03‚Äì01',‚Äô2019‚Äì03‚Äì22',20),

(2,‚Äô2019‚Äì02‚Äì01',‚Äô2019‚Äì02‚Äì20',15),

(2,‚Äô2019‚Äì02‚Äì21',‚Äô2019‚Äì03‚Äì31',30);

 

create table UnitsSold

(

product_id int,

purchase_date date,

units int

);

 

insert into UnitsSold

values

(1,‚Äô2019‚Äì02‚Äì25',100),

(1,‚Äô2019‚Äì03‚Äì01',15),

(2,‚Äô2019‚Äì02‚Äì10',200),

(2,‚Äô2019‚Äì03‚Äì22',30)

 

------------------------------------------------------------------------------------

Solution->

-------------------------------------------------------------------------------------

SELECT P.product_id, ROUND(CAST(SUM(P.price * U.units) AS DECIMAL) / SUM(U.units), 2) AS avg_price

FROM prices P

JOIN UnitsSold U ON P.product_id = U.product_id

WHERE U.purchase_date BETWEEN P.start_date AND P.end_date

GROUP BY P.product_id;

--------------------------------------------------------------------------------------#sql #database #dataanalyst #practices

#data #technology #learning #interview

#dataengineering #dataanalytics #scenarioanalysis

#sqlqueries #learningeveryday #day28 #scenario